package cmd

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/ashish-amarnath/slackbots/pkg/slack"
	"github.com/ashish-amarnath/slackbots/pkg/types"
	"github.com/ashish-amarnath/slackbots/pkg/utils"
	"github.com/golang/glog"
)

func getAccNumFromRoleArn(arnName string) (accNum string, err error) {
	err = nil
	accNum = ""
	roleArnParts := strings.Split(arnName, ":")
	if len(roleArnParts) != 6 {
		err = fmt.Errorf("%s doesn't ressemble an AWS IAM role arn", arnName)
		accNum = ""
	} else {
		accNum = roleArnParts[types.AccountNumberIndexInRoleArn]
		err = nil
	}
	return
}

func getAccountOwnerIDEndpoint(metadataServerURL, accNum string) string {
	return fmt.Sprintf("%s/%s=%s", metadataServerURL, types.AWSMetaDataServerAccRsrcEp, accNum)
}

func parseAccOwnerResponse(raw []byte) (respObj types.AccNumRespMsg, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func parseKubernetesNamespace(raw []byte) (respObj types.KubernetesNamespace, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func doHTTPRequest(url, apiKey string) (raw []byte, err error) {
	raw = nil
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		err := fmt.Errorf("failed to create request to url=%s err=%s", url, err.Error())
		glog.Error(err)
		return nil, err
	}
	req.Header.Set("X-Api-Key", apiKey)

	resp, err := http.DefaultClient.Do(req)
	if err != nil || resp.StatusCode != 200 {
		if resp == nil {
			err = fmt.Errorf("request to url=%s failed err=%s", url, err.Error())
		}
		glog.Error(err)
		return nil, err
	}

	raw, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	return raw, nil
}

func runRawCurlCommands(url string) (raw []byte, err error) {
	curlCmd := fmt.Sprintf("curl -s %s", url)
	out, err := utils.RunBashCmd(curlCmd)

	if err != nil {
		err = fmt.Errorf("failed to successfully run [%s] err=%s", curlCmd, err.Error())
		glog.Error(err)
		raw = nil
		return
	}
	raw = []byte(out)
	return
}

func getAWSAccountOwnerID(baseURL, apiKey, awsAccNum string) (ownerID string, err error) {
	url := getAccountOwnerIDEndpoint(baseURL, awsAccNum)
	ownerID = ""
	err = nil

	rBody, err := doHTTPRequest(url, apiKey)
	respJSON, err := parseAccOwnerResponse(rBody)
	if err != nil {
		err = fmt.Errorf("doHttpRequest to getAWSAccountOwnerID url=%s failed, err=%s", url, err.Error())
		glog.Error(err)
		ownerID = ""
	} else {
		err = nil
		ownerID = fmt.Sprintf("%d", respJSON.Data[0].OwnerTeamID)
	}
	return
}

func parseAdSecGrpResponse(raw []byte) (respObj types.AdSecurityGroupResp, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func getOwnerADSecurityGroup(baseURL, apiKey, ownerTeamID string) (adSecGrp string, err error) {
	url := fmt.Sprintf("%s/%s=%s", baseURL, types.ADSecurityGroupEndPoint, ownerTeamID)

	rBody, err := doHTTPRequest(url, apiKey)
	if err != nil {
		err = fmt.Errorf("doHttpRequest to url=%s failed, err=%s", url, err.Error())
		glog.Error(err)
		adSecGrp = ""
		return
	}
	respJSON, err := parseAdSecGrpResponse(rBody)
	if err != nil {
		err = fmt.Errorf("failed to parse response from end point %s, err=%s", url, err.Error())
		glog.Error(err)
		adSecGrp = ""
		return
	}

	err = nil
	adSecGrp = respJSON.Data[0].ADSecurityGroup
	return
}

func parseADGroupMemberListResp(raw []byte) (respJSON types.ADGroupMemberListResp, err error) {
	err = json.Unmarshal(raw, &respJSON)
	return
}

func parseADUserResp(raw []byte) (respJSON types.ADUser, err error) {
	err = json.Unmarshal(raw, &respJSON)
	return
}

func getAdGrpMembers(adGroupLkpURL, adSecGrp string) (owners []string, err error) {
	url := fmt.Sprintf("%s/%s", adGroupLkpURL, adSecGrp)

	out, err := runRawCurlCommands(url)
	if err != nil {
		err = fmt.Errorf("failed to successfully run runRawCurlCommands(%s) err=%s", url, err.Error())
		glog.Error(err)
		owners = nil
		return
	}
	adGrpMemberListResp, err := parseADGroupMemberListResp(out)
	owners = adGrpMemberListResp.Members.Users
	err = nil
	return
}

func getRoleOwners(adGrpListURL, mdsURL, mdsAPIKey, awsRoleArn string) (owners []string, err error) {
	owners = nil
	err = nil
	awsAccountNumber, err := getAccNumFromRoleArn(awsRoleArn)
	if err != nil {
		glog.Errorf("Failed to parse account number from role=[%s]\n", awsRoleArn)
		return
	}
	roleAccOwnerID, err := getAWSAccountOwnerID(mdsURL, mdsAPIKey, awsAccountNumber)
	if err != nil {
		glog.Errorf("Failed to get role owner ID for AWS account number=[%s]\n", awsAccountNumber)
		return
	}
	adSecGrp, err := getOwnerADSecurityGroup(mdsURL, mdsAPIKey, roleAccOwnerID)
	if err != nil {
		glog.Errorf("Failed to translate ownerID=[%s] to AD security group.\n", roleAccOwnerID)
		return
	}
	owners, err = getAdGrpMembers(adGrpListURL, adSecGrp)
	if err != nil {
		owners = nil
		glog.Errorf("Failed to get members of AD security group=[%s].\n", adSecGrp)
	}
	return
}

func getADUsrLookupEp(fName, lName, adLookupServerURL string) string {
	const comma = `%2c`
	const space = `%20`
	return fmt.Sprintf("%s/%s%s%s%s", adLookupServerURL, lName, comma, space, fName)
}

func getADUserByCN(fName, lName, email, adUsrLookupURL string) (usr types.ADUser, err error) {
	url := getADUsrLookupEp(fName, lName, adUsrLookupURL)
	out, err := runRawCurlCommands(url)
	if err != nil {
		err = fmt.Errorf("failed to successfully run [%s] err=%s", url, err.Error())
		glog.Error(err)
	}

	usr, err = parseADUserResp(out)
	if strings.ToLower(usr.Email) != strings.ToLower(email) {
		errStr := fmt.Sprintf("AD user's Email=[%s] doesn't match Slack user=[%s]", usr.Email, email)
		glog.Error(errStr)
		err = fmt.Errorf(errStr)
	}

	return
}

func getADUserForSlackUser(slackUID, adUsrLookupURL string) (adUsr types.ADUser, err error) {
	su := slack.SlackUserMap[slackUID]
	glog.V(1).Infof("SlackUser=%s\n", utils.StringifySlackUser(su))
	adUsr, err = getADUserByCN(su.Profile.FirstName, su.Profile.LastName, su.Profile.Email, adUsrLookupURL)
	glog.V(1).Infof("AD user=%s\n", utils.StringifyADUser(adUsr))
	return
}

func isRequestorOwner(su, adUsrLookupURL string, owners []string) bool {
	adUsr, err := getADUserForSlackUser(su, adUsrLookupURL)
	if err != nil {
		glog.Errorf("Unable to get AD user for <@%s>", su)
		return false
	}
	matcherKey := fmt.Sprintf("%s, %s", adUsr.LastName, adUsr.FirstName)
	res := false
	// Do better than linear search? Hopefully this is a small slice
	for _, owner := range owners {
		if owner == matcherKey {
			res = true
			break
		}
	}
	return res
}

func isRequestValid(botReqParams types.BotReqParams) bool {
	return botReqParams.ADGroupLookupURL != "" &&
		botReqParams.ADUserLookupURL != "" &&
		botReqParams.AWSAPIKey != "" &&
		botReqParams.AWSMetadataServerURL != "" &&
		botReqParams.KubeConfig != "" &&
		botReqParams.Message != "" &&
		botReqParams.SlackUser != "" &&
		len(strings.Split(botReqParams.Message, " ")) == types.Kube2IamBotReqLength
}

// RequestKube2IamReq validates kube2iam request
func RequestKube2IamReq(botParams types.BotReqParams) string {

	if !isRequestValid(botParams) {
		return fmt.Sprintf("ERROR:\n Request should be of the form \n %s Order is important. Received ```%s```", types.RequestKube2IamBotReqFormat, botParams.Message)
	}

	msgParts := strings.Split(botParams.Message, " ")
	var resp string

	namespace := msgParts[2]
	awsRoleArn := msgParts[3]
	cluster := msgParts[4]

	owners, err := getRoleOwners(botParams.ADGroupLookupURL, botParams.AWSMetadataServerURL, botParams.AWSAPIKey, awsRoleArn)
	if err != nil {
		return fmt.Sprintf("Failed to get owners of awsRoleArn=%s. err=%s", awsRoleArn, err.Error())
	}

	if isRequestorOwner(botParams.SlackUser, botParams.ADUserLookupURL, owners) {
		resp = ApproveKube2IamReq(botParams)
	} else {
		approveMsg := fmt.Sprintf("```%s %s %s %s```", types.ApproveKube2IamBotReq, namespace, awsRoleArn, cluster)
		resp = fmt.Sprintf("Hi <@%s>,\nOwners of ARN [%s] are\n %s.\n Please have one of the owners copy paste\n %s",
			botParams.SlackUser, awsRoleArn, strings.Join(owners, "\n"), approveMsg)
	}
	return resp
}

func addNewKube2IamRole(currentAllowedRoles, newRole string) string {
	var newRoleSet string
	currentAllowedRoles = strings.Trim(currentAllowedRoles, "\n")
	glog.V(1).Infof("%s %t", currentAllowedRoles, currentAllowedRoles == "[]")
	if currentAllowedRoles == "[]" {
		newRoleSet = fmt.Sprintf("[\"%s\"]", newRole)
	} else {
		currentAllowedRoles = strings.Trim(currentAllowedRoles, "[")
		currentAllowedRoles = strings.Trim(currentAllowedRoles, "]")
		newRoleSet = "["
		roleAlreadyExists := false
		for _, role := range strings.Split(currentAllowedRoles, ",") {
			glog.V(1).Infof("kube2IamRole=%s", role)
			newRoleSet += fmt.Sprintf("%s,", role)

			if role == "\""+newRole+"\"" {
				roleAlreadyExists = true
			}
		}
		if !roleAlreadyExists {
			newRoleSet += fmt.Sprintf("\"%s\"", newRole)
		} else {
			glog.V(6).Infof("Role %s exists in %s", newRole, currentAllowedRoles)
		}
		newRoleSet = strings.Trim(newRoleSet, ",")
		newRoleSet += "]"
	}

	glog.V(8).Infof("newRoleSet=%s\n", newRoleSet)
	return newRoleSet
}

// ApproveKube2IamReq applies kube2iam annotations to namespaces
func ApproveKube2IamReq(botReqParams types.BotReqParams) string {
	if !isRequestValid(botReqParams) {
		return fmt.Sprintf("ERROR:\n Request should be of the form \n %s Order is important. Received ```%s```", types.ApproveKube2IamBotReqFormat, botReqParams.Message)
	}

	glog.V(1).Infof("Received request %s\n", utils.StringifyBotReqParams(botReqParams))

	msgTxtArr := strings.Split(botReqParams.Message, " ")
	var resp string
	namespace := msgTxtArr[2]
	awsRoleArn := msgTxtArr[3]
	cluster := msgTxtArr[4]

	roleOwners, err := getRoleOwners(botReqParams.ADGroupLookupURL, botReqParams.AWSMetadataServerURL, botReqParams.AWSAPIKey, awsRoleArn)
	if err != nil {
		resp = fmt.Sprintf("Failed to get owners of role=%s", awsRoleArn)
		glog.Errorf(resp)
		return resp
	}

	if !isRequestorOwner(botReqParams.SlackUser, botReqParams.ADUserLookupURL, roleOwners) {
		resp = fmt.Sprintf("User <@%s> is not allowed to approve kube2Iam requests for role %s to namespace %s", botReqParams.SlackUser, awsRoleArn, namespace)
		glog.Errorf(resp)
		return resp
	}

	nsJSON, err := utils.GetNamespaceDefnJSON(botReqParams.KubeConfig, cluster, namespace)
	if err != nil {
		resp = fmt.Sprintf("Failed to get namespace definition for namepsace=%s in cluster=%s. err=%s", namespace, cluster, err.Error())
		glog.Errorf(resp)
		return resp
	}
	nsObj, err := parseKubernetesNamespace([]byte(nsJSON))
	if err != nil {
		resp = fmt.Sprintf("failed to parse namespace definition for namespace=%s, %s", namespace, err.Error())
		glog.Errorf(resp)
		return resp
	}

	nsObj.Metadata.Annotations.Kube2IamAllowedRoles = addNewKube2IamRole(nsObj.Metadata.Annotations.Kube2IamAllowedRoles, awsRoleArn)
	var marshalled []byte
	marshalled, err = json.Marshal(nsObj)
	if err != nil {
		resp = fmt.Sprintf("failed to marshall updated namespace metadata, err=%s", err.Error())
		glog.Errorf(resp)
		return resp
	}
	err = utils.UpdateNamespaceDefn(botReqParams.KubeConfig, cluster, nsObj.Metadata.Name, string(marshalled))
	if err != nil {
		resp = fmt.Sprintf("failed to update namespace metadata for namespace=%s in cluster=%s", namespace, cluster)
		return resp
	}
	resp = fmt.Sprintf("Successsfully updated allowed roles on namespace=%s.\nAllowedRoles=[%s]", namespace, nsObj.Metadata.Annotations.Kube2IamAllowedRoles)

	return resp
}

func getRespMsg(req types.Message) types.Message {
	return types.Message{
		ID:      req.ID,
		Channel: req.Channel,
		Type:    req.Type,
		User:    req.User,
	}
}

func getSupportedRequestTypes() string {
	return "This Bot can help you with the following requests:\n" +
		fmt.Sprintf("%s\n%s\n", types.RequestKube2IamBotReqFormat, types.ApproveKube2IamBotReqFormat)
}

// ProcessBotRquest processes the request based on the request type
func ProcessBotRquest(slackConn *slack.ServerConn, req types.Message, adGroupLookupURL, metadataServerURL, metadataServerAPIKey, kubeconfig, adUsrLookupURL string) {
	reqText := req.Text
	glog.V(2).Infof("Received request: %s\n", utils.StringifyMessage(req))

	botReqType := utils.GetBotReqType(reqText)

	botReqParams := utils.GetBotReqParams(adGroupLookupURL, adUsrLookupURL, metadataServerURL, metadataServerAPIKey, kubeconfig, reqText, req.User)
	glog.V(6).Infof("%s\n", utils.StringifyBotReqParams(botReqParams))

	var respText string
	if botReqType == types.RequestKube2IamBotReq {
		respText = RequestKube2IamReq(botReqParams)
	} else if botReqType == types.ApproveKube2IamBotReq {
		respText = ApproveKube2IamReq(botReqParams)
	} else if botReqType == types.HelpBotReq {
		respText = getSupportedRequestTypes()
	} else {
		respText = fmt.Sprintf("Unknown request type [%s]\n", botReqType) + getSupportedRequestTypes()
	}

	resp := getRespMsg(req)
	resp.Text = respText

	slackConn.SendMessage(resp)
}
