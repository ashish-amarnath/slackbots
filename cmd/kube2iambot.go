package cmd

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os/exec"
	"strings"

	"github.com/ashish-amarnath/slackbots/pkg/types"
	"github.com/ashish-amarnath/slackbots/pkg/utils"
	"github.com/golang/glog"
)

func getAccNumFromRoleArn(arnName string) (accNum string, err error) {
	err = nil
	accNum = ""
	roleArnParts := strings.Split(arnName, ":")
	if len(roleArnParts) != 6 {
		err = fmt.Errorf("%s doesn't ressemble an AWS IAM role arn", arnName)
		accNum = ""
	} else {
		accNum = roleArnParts[types.AccountNumberIndexInRoleArn]
		err = nil
	}
	return
}

func getAccountOwnerIDEndpoint(metadataServerURL, accNum string) string {
	return fmt.Sprintf("%s/%s=%s", metadataServerURL, types.AWSMetaDataServerAccRsrcEp, accNum)
}

func parseAccOwnerResponse(raw []byte) (respObj types.AccNumRespMsg, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func parseKubernetesNamespaceMetadata(raw []byte) (respObj types.KubernetesNamespaceMetadata, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func doHTTPRequest(url, apiKey string) (raw []byte, err error) {
	raw = nil
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		err := fmt.Errorf("failed to create request to url=%s err=%s", url, err)
		glog.Error(err)
		return nil, err
	}
	req.Header.Set("X-Api-Key", apiKey)

	resp, err := http.DefaultClient.Do(req)
	if err != nil || resp.StatusCode != 200 {
		if resp == nil {
			err = fmt.Errorf("request to url=%s failed err=%s", url, err)
		} else {
			err = fmt.Errorf("request to url=%s failed err=%s, httpStatusCode=%d(%s)", url, err, resp.StatusCode, resp.Status)
		}
		glog.Error(err)
		return nil, err
	}

	raw, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	return raw, nil
}

func getAWSAccountOwnerID(baseURL, apiKey, awsAccNum string) (ownerID string, err error) {
	url := getAccountOwnerIDEndpoint(baseURL, awsAccNum)
	ownerID = ""
	err = nil

	rBody, err := doHTTPRequest(url, apiKey)
	respJSON, err := parseAccOwnerResponse(rBody)
	if err != nil {
		err = fmt.Errorf("doHttpRequest to getAWSAccountOwnerID url=%s failed, err=%s", url, err)
		glog.Error(err)
		ownerID = ""
	} else {
		err = nil
		ownerID = fmt.Sprintf("%d", respJSON.Data[0].OwnerTeamID)
	}
	return
}

func parseAdSecGrpResponse(raw []byte) (respObj types.AdSecurityGroupResp, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func getOwnerADSecurityGroup(baseURL, apiKey, ownerTeadID string) string {
	url := fmt.Sprintf("%s/%s=%s", baseURL, types.ADSecurityGroupEndPoint, ownerTeadID)

	rBody, err := doHTTPRequest(url, apiKey)
	if err != nil {
		err := fmt.Errorf("doHttpRequest to url=%s failed, err=%s", url, err)
		glog.Error(err)
		return err.Error()
	}
	respJSON, err := parseAdSecGrpResponse(rBody)
	if err != nil {
		err := fmt.Errorf("failed to parse response from end point %s, err=%s", url, err)
		glog.Error(err)
		return err.Error()
	}

	return respJSON.Data[0].ADSecurityGroup
}

func parseADGroupMemberListResp(raw []byte) (respJSON types.ADGroupMemberListResp, err error) {
	err = json.Unmarshal(raw, &respJSON)
	return
}

func getAdGrpMembers(adGroupMemberlistURL, adSecGrp string) string {
	curlCmd := fmt.Sprintf("curl -s %s/%s", adGroupMemberlistURL, adSecGrp)
	glog.V(5).Infof("curlCmd: %s", curlCmd)
	cmd := exec.Command("bash", "-c", curlCmd)
	out, err := cmd.Output()
	if err != nil {
		glog.Errorf("failed to successfully run [%s] err=%s", curlCmd, err)
		return err.Error()
	}
	adGrpMemberListResp, err := parseADGroupMemberListResp(out)
	return strings.Join(adGrpMemberListResp.Members.Users, ", ")
}

// ValidateKube2IamReq validates kube2iam request
func ValidateKube2IamReq(adGrpListURL, mdsURL, mdsAPIKey, msg string) string {
	msgParts := strings.Split(msg, " ")
	usage := fmt.Sprintf("ERROR:\n Request should be of the form ```%s <namespace> <roleArn> <cluster>``` Order is important. Received ```%s```", types.ValidateKube2IamBotReq, msg)
	var resp string

	//TODO remove magic numbers
	if len(msgParts) != 4 {
		return usage
	}

	namespace := msgParts[1]
	awsRoleArn := msgParts[2]
	cluster := msgParts[3]

	awsAccountNumber, err := getAccNumFromRoleArn(awsRoleArn)
	if err != nil {
		return fmt.Sprintf("err:%s\n %s\n", err.Error(), usage)
	}

	roleAccOwnerID, err := getAWSAccountOwnerID(mdsURL, mdsAPIKey, awsAccountNumber)
	if err != nil {
		return fmt.Sprintf("err:%s\n %s\n", err.Error(), usage)
	}
	adSecGrp := getOwnerADSecurityGroup(mdsURL, mdsAPIKey, roleAccOwnerID)
	nextStep := fmt.Sprintf("K8s admin copy paste \n ```%s %s %s %s``` \n OR \n ```%s %s %s```\n as appropriate",
		types.ApplysKube2IamBotReq, namespace, awsRoleArn, cluster, types.RejectKube2IamBotReq, namespace, awsRoleArn)
	resp = fmt.Sprintf("Owners of ARN [%s] are [%s]\n %s", awsRoleArn, getAdGrpMembers(adGrpListURL, adSecGrp), nextStep)
	return resp
}

func addNewKube2IamRole(currentAllowedRoles, newRole string) string {
	var newRoleSet string
	currentAllowedRoles = strings.Trim(currentAllowedRoles, "\n")
	glog.V(1).Infof("%s %t", currentAllowedRoles, currentAllowedRoles == "[]")
	if currentAllowedRoles == "[]" {
		newRoleSet = fmt.Sprintf("[\"%s\"]", newRole)
	} else {
		currentAllowedRoles = strings.Trim(currentAllowedRoles, "[")
		currentAllowedRoles = strings.Trim(currentAllowedRoles, "]")
		newRoleSet = "["
		roleAlreadyExists := false
		for _, role := range strings.Split(currentAllowedRoles, ",") {
			glog.V(1).Infof("kube2IamRole=%s", role)
			newRoleSet += fmt.Sprintf("%s,", role)

			if role == "\""+newRole+"\"" {
				roleAlreadyExists = true
			}
		}
		if !roleAlreadyExists {
			newRoleSet += fmt.Sprintf("\"%s\"", newRole)
		} else {
			glog.V(6).Infof("Role %s exists in %s", newRole, currentAllowedRoles)
		}
		newRoleSet = strings.Trim(newRoleSet, ",")
		newRoleSet += "]"
	}

	glog.V(8).Infof("newRoleSet=%s\n", newRoleSet)
	return newRoleSet
}

// ApplyKube2IamReq applies kube2iam annotations to namespaces
func ApplyKube2IamReq(msgText, kubeconfig string) string {
	msgTxtArr := strings.Split(msgText, " ")
	var resp string
	namespace := msgTxtArr[1]
	awsRoleArn := msgTxtArr[2]
	cluster := msgTxtArr[3]

	nsJSON, err := utils.GetNamespaceDefnJSON(kubeconfig, cluster, namespace)
	if err != nil {
		resp = fmt.Sprintf("Failed to get namespace definition for namepsace=%s in cluster=%s. err=%s", namespace, cluster, err.Error())
	} else {
		nsObj, err := parseKubernetesNamespaceMetadata([]byte(nsJSON))
		if err != nil {
			resp = fmt.Sprintf("failed to parse namespace metadata definition for namespace=%s, %s", namespace, err.Error())
		} else {
			glog.V(1).Infof("allowedRoles:%s", nsObj.Metadata.Annotations.Kube2IamBetaNordstromNetAllowedRoles)
			resp = "```" + fmt.Sprintf("CurrentRoles=%s", nsObj.Metadata.Annotations.Kube2IamBetaNordstromNetAllowedRoles)
			nsObj.Metadata.Annotations.Kube2IamBetaNordstromNetAllowedRoles = addNewKube2IamRole(nsObj.Metadata.Annotations.Kube2IamBetaNordstromNetAllowedRoles, awsRoleArn)
			var marshalled []byte
			marshalled, err = json.Marshal(nsObj)
			if err != nil {
				resp = fmt.Sprintf("failed to marshall updated namespace metadata, err=%s", err)
				glog.Errorf("resp")
			}
			err = utils.ApplyUpdatedNamespaceMetadata(kubeconfig, cluster, string(marshalled))
			if err != nil {
				resp = fmt.Sprintf("failed to update namespace metadata for namespace=%s in cluster=%s", namespace, cluster)
			} else {
				resp += fmt.Sprintf("UpdatedRoles=%s", nsObj.Metadata.Annotations.Kube2IamBetaNordstromNetAllowedRoles) + "```"
			}
		}
	}

	return resp
}

// RejectKube2IamReq should get human intervention to process this request
func RejectKube2IamReq(msgText string) string {
	// TODO: notify requester about rejection
	return fmt.Sprintf("Go get a human to help out... NOW!!!")
}

// ProcessBotRquest processes the request based on the request type
func ProcessBotRquest(botReq, adLookupServerURL, metadataServerURL, metadataServerAPIKey, kubeconfig string) string {
	glog.V(9).Infof("msgTxt: %s\n", botReq)

	botReqType := utils.GetBotReqType(botReq)
	var botResp string
	if botReqType == types.ValidateKube2IamBotReq {
		botResp = ValidateKube2IamReq(adLookupServerURL, metadataServerURL, metadataServerAPIKey, botReq)
	} else if botReqType == types.ApplysKube2IamBotReq {
		botResp = ApplyKube2IamReq(botReq, kubeconfig)
	} else if botReqType == types.RejectKube2IamBotReq {
		botResp = RejectKube2IamReq(botReq)
	} else {
		glog.V(6).Infof("Unknown botReq %s", botReqType)
	}

	return botResp
}
