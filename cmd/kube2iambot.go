package cmd

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os/exec"
	"strings"

	"github.com/ashish-amarnath/slackbots/pkg/types"
	"github.com/golang/glog"
)

func getAccNumFromRoleArn(arnName string) string {
	roleArnParts := strings.Split(arnName, ":")

	return roleArnParts[types.AccountNumberIndexInRoleArn]
}

func getAccountOwnerIDEndpoint(metadataServerURL, accNum string) string {
	return fmt.Sprintf("%s/%s=%s", metadataServerURL, types.AWSMetaDataServerAccRsrcEp, accNum)
}

func parseAccOwnerResponse(raw []byte) (respObj types.AccNumRespMsg, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func getAWSAccountOwnerID(url, apiKey, awsAccNum string) string {
	accountOwnerIDEndpoint := getAccountOwnerIDEndpoint(url, awsAccNum)
	glog.V(1).Infof("Meta-data server url=%s\n", accountOwnerIDEndpoint)

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", accountOwnerIDEndpoint, nil)
	if err != nil {
		err := fmt.Errorf("failed to create request to accountOwnerIDEndpoint at %s err=%s", accountOwnerIDEndpoint, err)
		glog.Error(err)
		return err.Error()
	}
	req.Header.Set("X-Api-Key", apiKey)

	resp, err := http.DefaultClient.Do(req)
	if err != nil || resp.StatusCode != 200 {
		err := fmt.Errorf("failed to get account ownerID for account number=%s err=%s httpsStatusCode=%d[%s]", awsAccNum, err, resp.StatusCode, resp.Status)
		glog.Error(err)
		return err.Error()
	}

	rBody, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	respJSON, err := parseAccOwnerResponse(rBody)

	var teamOwnerID string
	if err != nil {
		glog.Errorf("failed to parse response from end point %s, err=%s", accountOwnerIDEndpoint, err)
		teamOwnerID = ""
	} else {
		glog.V(1).Infof("accName=%s accountNumber=%s ownerID=%d\n", respJSON.Data[0].AccountName, respJSON.Data[0].AccountNumber, respJSON.Data[0].OwnerTeamID)

		teamOwnerID = fmt.Sprintf("%d", respJSON.Data[0].OwnerTeamID)
	}
	return teamOwnerID
}

func parseAdSecGrpResponse(raw []byte) (respObj types.AdSecurityGroupResp, err error) {
	err = json.Unmarshal(raw, &respObj)
	return
}

func getOwnerADSecurityGroup(url, apiKey, ownerTeadID string) string {
	adSecGrpEndPoint := fmt.Sprintf("%s/%s=%s", url, types.ADSecurityGroupEndPoint, ownerTeadID)
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", adSecGrpEndPoint, nil)
	if err != nil {
		err := fmt.Errorf("failed to create new HTTP request to adSecGrpEndPoint at %s err=%s", url, err)
		glog.Error(err)
		return err.Error()
	}
	req.Header.Set("X-Api-Key", apiKey)

	resp, err := http.DefaultClient.Do(req)
	if err != nil || resp.StatusCode != 200 {
		err := fmt.Errorf("request to adSecGrpEndpoint at %s failed, err=%s httpStatusCode=%d(%s)", adSecGrpEndPoint, err, resp.StatusCode, resp.Status)
		glog.Error(err)
		return err.Error()
	}
	rBody, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()

	respJSON, err := parseAdSecGrpResponse(rBody)
	var adSecGrp string
	if err != nil {
		glog.Errorf("failed to parse response from end point %s, err=%s", adSecGrpEndPoint, err)
		adSecGrp = ""
	} else {
		adSecGrp = respJSON.Data[0].ADSecurityGroup
		glog.V(1).Infof("AdSecGrp=%s\n", adSecGrp)
	}

	return adSecGrp
}

func parseADGroupMemberListResp(raw []byte) (respJSON types.ADGroupMemberListResp, err error) {
	err = json.Unmarshal(raw, &respJSON)
	return
}

func getAdSecGrpMembers(adGroupMemberlistURL, adSecGrp string) string {
	curlCmd := fmt.Sprintf("curl -s %s/%s", adGroupMemberlistURL, adSecGrp)
	glog.V(1).Infof("curlCmd: %s", curlCmd)
	cmd := exec.Command("bash", "-c", curlCmd)
	out, err := cmd.Output()
	if err != nil {
		glog.Errorf("failed to successfully run [%s] err=%s", curlCmd, err)
		return err.Error()
	}
	adGrpMemberListResp, err := parseADGroupMemberListResp(out)
	glog.V(1).Infof("members:\n[%s]\n", strings.Join(adGrpMemberListResp.Members.Users, ", "))
	return strings.Join(adGrpMemberListResp.Members.Users, ", ")
}

// ProcessValidateKube2IamReq validates kube2iam request
func ProcessValidateKube2IamReq(adGroupMemberlistURL, metaDataServerURL, metadataServerAPIKey, msg string) string {
	msgParts := strings.Split(msg, " ")
	awsRoleArn := msgParts[1]
	awsAccountNumber := getAccNumFromRoleArn(awsRoleArn)

	roleAccOwnerID := getAWSAccountOwnerID(metaDataServerURL, metadataServerAPIKey, awsAccountNumber)
	adSecGrp := getOwnerADSecurityGroup(metaDataServerURL, metadataServerAPIKey, roleAccOwnerID)

	return getAdSecGrpMembers(adGroupMemberlistURL, adSecGrp)
}

// ApplyKube2IamReq applies kube2iam annotations to namespaces
func ApplyKube2IamReq(msgText string) string {
	msgTxtArr := strings.Split(msgText, " ")
	namespace := msgTxtArr[1]
	awsRoleArn := msgTxtArr[2]

	resp := fmt.Sprintf("Allowing pods in namespace=%s to assume role=%s", namespace, awsRoleArn)
	glog.V(1).Infof(resp)

	return resp
}
